!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module pppack ! in 
    interface  ! in :pppack
        module ppcolloc_data ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(2000) :: coef
            integer(kind=4), parameter,optional :: ncoef=2000
            real(kind=8) dimension(100) :: breaks
            integer(kind=4), parameter,optional :: npiece=100
            integer(kind=4) :: l
            integer(kind=4) :: kpm
        end module ppcolloc_data
        module colloc_data ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(20) :: xside
            integer(kind=4) :: iside
            real(kind=8) dimension(19) :: rho
            integer(kind=4) :: itermx
            integer(kind=4) :: k
            integer(kind=4) :: m
        end module colloc_data
        module l2approx_data ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4), parameter,optional :: ltkmax=2000
            real(kind=8) dimension(100) :: breaks
            integer(kind=4), parameter,optional :: lpkmax=100
            real(kind=8) dimension(2000) :: coef
            integer(kind=4) :: k
            integer(kind=4) :: l
        end module l2approx_data
        module l2ir_data ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4) :: ntau
            real(kind=8) dimension(200) :: tau
            real(kind=8) dimension(200) :: weight
            integer(kind=4), parameter,optional :: ntmax=200
            real(kind=8) :: totalw
            real(kind=8) dimension(200) :: gtau
        end module l2ir_data
        subroutine banfac(w,nroww,nrow,nbandl,nbandu,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nroww,nrow),intent(inout) :: w
            integer(kind=4), optional,intent(in),check(shape(w,0)==nroww),depend(w) :: nroww=shape(w,0)
            integer(kind=4), optional,intent(in),check(shape(w,1)==nrow),depend(w) :: nrow=shape(w,1)
            integer(kind=4) intent(in) :: nbandl
            integer(kind=4) intent(in) :: nbandu
            integer(kind=4) intent(out) :: iflag
        end subroutine banfac
        subroutine banslv(w,nroww,nrow,nbandl,nbandu,b) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nroww,nrow),intent(in) :: w
            integer(kind=4), optional,intent(in),check(shape(w,0)==nroww),depend(w) :: nroww=shape(w,0)
            integer(kind=4), optional,intent(in),check(shape(w,1)==nrow),depend(w) :: nrow=shape(w,1)
            integer(kind=4) intent(in) :: nbandl
            integer(kind=4) intent(in) :: nbandu
            real(kind=8) dimension(nrow),intent(inout),depend(nrow) :: b
        end subroutine banslv
        subroutine bchfac(w,nbands,nrow,diag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nbands,nrow),intent(inout) :: w
            integer(kind=4), optional,intent(in),check(shape(w,0)==nbands),depend(w) :: nbands=shape(w,0)
            integer(kind=4), optional,intent(in),check(shape(w,1)==nrow),depend(w) :: nrow=shape(w,1)
            real(kind=8) dimension(nrow),intent(out),depend(nrow) :: diag
        end subroutine bchfac
        subroutine bchslv(w,nbands,nrow,b) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nbands,nrow),intent(in) :: w
            integer(kind=4), optional,intent(in),check(shape(w,0)==nbands),depend(w) :: nbands=shape(w,0)
            integer(kind=4), optional,intent(in),check(shape(w,1)==nrow),depend(w) :: nrow=shape(w,1)
            real(kind=8) dimension(nrow),intent(inout),depend(nrow) :: b
        end subroutine bchslv
        subroutine bsplpp(t,bcoef,n,k,scrtch,breaks,coef,l) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(n+k),intent(in),depend(n,k) :: t
            real(kind=8) dimension(n),intent(in) :: bcoef
            integer(kind=4), optional,intent(in),check(len(bcoef)>=n),depend(bcoef) :: n=len(bcoef)
            integer(kind=4) intent(in) :: k
            real(kind=8) dimension(k,k),intent(out),depend(k,k) :: scrtch
            real(kind=8) dimension(n + 1),intent(out),depend(n) :: breaks
            real(kind=8) dimension(k,n),intent(out),depend(k,n) :: coef
            integer(kind=4) intent(out) :: l
        end subroutine bsplpp
        subroutine bsplvb(t,jhigh,index_bn,x,left,biatx) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(left+jhigh),intent(in),depend(jhigh,left) :: t
            integer(kind=4) intent(in) :: jhigh
            integer(kind=4) intent(in) :: index_bn
            real(kind=8) intent(in) :: x
            integer(kind=4) intent(in) :: left
            real(kind=8) dimension(jhigh),intent(out),depend(jhigh) :: biatx
        end subroutine bsplvb
        subroutine bsplvd(t,k,x,left,a,dbiatx,nderiv) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(left+k),intent(in),depend(k,left) :: t
            integer(kind=4) intent(in) :: k
            real(kind=8) intent(in) :: x
            integer(kind=4) intent(in) :: left
            real(kind=8) dimension(k,k),intent(out),depend(k,k) :: a
            real(kind=8) dimension(k,nderiv),intent(out),depend(k,nderiv) :: dbiatx
            integer(kind=4) intent(in) :: nderiv
        end subroutine bsplvd
        subroutine bspp2d(t,bcoef,n,k,m,scrtch,breaks,coef,l) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(n+k),intent(in),depend(n,k) :: t
            real(kind=8) dimension(n,m),intent(in) :: bcoef
            integer(kind=4), optional,intent(in),check(shape(bcoef,0)==n),depend(bcoef) :: n=shape(bcoef,0)
            integer(kind=4) intent(in) :: k
            integer(kind=4), optional,intent(in),check(shape(bcoef,1)==m),depend(bcoef) :: m=shape(bcoef,1)
            real(kind=8) dimension(k,k,m),intent(out),depend(k,k,m) :: scrtch
            real(kind=8) dimension(*),intent(out) :: breaks
            real(kind=8) dimension(m,k,*),intent(out),depend(m,k) :: coef
            integer(kind=4) intent(out) :: l
        end subroutine bspp2d
        function bvalue(t,bcoef,n,k,x,jderiv) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(n+k),intent(in),depend(n,k) :: t
            real(kind=8) dimension(n),intent(in) :: bcoef
            integer(kind=4), optional,intent(in),check(len(bcoef)>=n),depend(bcoef) :: n=len(bcoef)
            integer(kind=4) intent(in) :: k
            real(kind=8) intent(in) :: x
            integer(kind=4) intent(in) :: jderiv
            real(kind=8) :: bvalue
        end function bvalue
        subroutine bvalnd(t,bcoef,n,m,k,x,jderiv,bvalue) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(n+k),intent(in),depend(n,k) :: t
            real(kind=8) dimension(*,*),intent(in) :: bcoef
            integer(kind=4), optional,intent(in),depend(bcoef) :: n=shape(bcoef,0)
            integer(kind=4), optional,intent(in),check(n*m == shape(bcoef,0)*shape(bcoef,1)),depend(bcoef,n) :: m=shape(bcoef,1)
            integer(kind=4) intent(in) :: k
            real(kind=8) intent(in) :: x
            integer(kind=4) intent(in) :: jderiv
            real(kind=8) dimension(m),intent(out),depend(m) :: bvalue
        end subroutine bvalnd
        subroutine chol1d(p,v,qty,npoint,ncol,u,qu) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) intent(in) :: p
            real(kind=8) dimension(npoint,7),intent(inout) :: v
            real(kind=8) dimension(npoint),intent(in),depend(npoint) :: qty
            integer(kind=4), optional,intent(in),check(shape(v,0)==npoint),depend(v) :: npoint=shape(v,0)
            integer(kind=4) intent(in) :: ncol
            real(kind=8) dimension(npoint),intent(out),depend(npoint) :: u
            real(kind=8) dimension(npoint),intent(out),depend(npoint) :: qu
        end subroutine chol1d
        subroutine colloc(aleft,aright,lbegin,iorder,ntimes,addbrk,relerr) ! in :pppack:../../src/pppack/f90/pppack.f90
            use colloc_data
            use ppcolloc_data
            real(kind=8) intent(in) :: aleft
            real(kind=8) intent(in) :: aright
            integer(kind=4) intent(in) :: lbegin
            integer(kind=4) intent(in) :: iorder
            integer(kind=4) intent(in) :: ntimes
            real(kind=8) intent(in) :: addbrk
            real(kind=8) intent(in) :: relerr
        end subroutine colloc
        subroutine colpnt(k,rho) ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4) intent(in) :: k
            real(kind=8) dimension(k),intent(out),depend(k) :: rho
        end subroutine colpnt
        subroutine cubspl(tau,c,n,ibcbeg,ibcend) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(n),intent(in) :: tau
            real(kind=8) dimension(4,n),intent(inout),depend(n) :: c
            integer(kind=4), optional,intent(in),check(len(tau)>=n),depend(tau) :: n=len(tau)
            integer(kind=4) intent(in) :: ibcbeg
            integer(kind=4) intent(in) :: ibcend
        end subroutine cubspl
        subroutine cwidth(w,b,nequ,ncols,integs,nbloks,d,x,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nequ,ncols) :: w
            real(kind=8) dimension(nequ),intent(inout),depend(nequ) :: b
            integer(kind=4), optional,intent(in),check(shape(w,0)==nequ),depend(w) :: nequ=shape(w,0)
            integer(kind=4), optional,intent(in),check(shape(w,1)==ncols),depend(w) :: ncols=shape(w,1)
            integer(kind=4) dimension(2,nbloks),intent(in) :: integs
            integer(kind=4), optional,intent(in),check(shape(integs,1)==nbloks),depend(integs) :: nbloks=shape(integs,1)
            real(kind=8) dimension(nequ),intent(out),depend(nequ) :: d
            real(kind=8) dimension(nequ),intent(out),depend(nequ) :: x
            integer(kind=4) intent(out) :: iflag
        end subroutine cwidth
        subroutine difequ(mode,xx,v) ! in :pppack:../../src/pppack/f90/pppack.f90
            use colloc_data
            use ppcolloc_data
            integer(kind=4) intent(in) :: mode
            real(kind=8) intent(in) :: xx
            real(kind=8) dimension(20),intent(out) :: v
        end subroutine difequ
        subroutine dtblok(bloks,integs,nbloks,ipivot,iflag,detsgn,detlog) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(*),intent(in) :: bloks
            integer(kind=4) dimension(3,nbloks),intent(in) :: integs
            integer(kind=4), optional,intent(in),check(shape(integs,1)==nbloks),depend(integs) :: nbloks=shape(integs,1)
            integer(kind=4) dimension(1),intent(in) :: ipivot
            integer(kind=4) intent(in) :: iflag
            real(kind=8) intent(out) :: detsgn
            real(kind=8) intent(out) :: detlog
        end subroutine dtblok
        subroutine eqblok(t,n,kpm,work1,work2,bloks,lenblk,integs,nbloks,b) ! in :pppack:../../src/pppack/f90/pppack.f90
            use colloc_data
            real(kind=8) dimension(n+kpm),intent(in),depend(n,kpm) :: t
            integer(kind=4) intent(in) :: n
            integer(kind=4) intent(in) :: kpm
            real(kind=8) dimension(kpm,kpm),intent(out),depend(kpm,kpm) :: work1
            real(kind=8) dimension(kpm,*),intent(out),depend(kpm) :: work2
            real(kind=8) dimension(*),intent(out) :: bloks
            integer(kind=4) intent(in) :: lenblk
            integer(kind=4) dimension(3,*),intent(out) :: integs
            integer(kind=4) intent(out) :: nbloks
            real(kind=8) dimension(*),intent(out) :: b
        end subroutine eqblok
        subroutine evnnot(breaks,coef,l,k,brknew,lnew,coefg) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(l + 1),intent(in) :: breaks
            real(kind=8) dimension(k,l),intent(in),depend(l) :: coef
            integer(kind=4), optional,intent(in),check((len(breaks)-1)>=l),depend(breaks) :: l=(len(breaks)-1)
            integer(kind=4), optional,intent(in),check(shape(coef,0)==k),depend(coef) :: k=shape(coef,0)
            real(kind=8) dimension(lnew + 1),intent(out),depend(lnew) :: brknew
            integer(kind=4) intent(in) :: lnew
            real(kind=8) dimension(2,l),intent(out),depend(l) :: coefg
        end subroutine evnnot
        subroutine factrb(w,ipivot,d,nrow,ncol,last,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nrow,ncol),intent(inout) :: w
            integer(kind=4) dimension(nrow),intent(out),depend(nrow) :: ipivot
            real(kind=8) dimension(nrow),intent(out),depend(nrow) :: d
            integer(kind=4), optional,intent(in),check(shape(w,0)==nrow),depend(w) :: nrow=shape(w,0)
            integer(kind=4), optional,intent(in),check(shape(w,1)==ncol),depend(w) :: ncol=shape(w,1)
            integer(kind=4) intent(in) :: last
            integer(kind=4) intent(inout) :: iflag
        end subroutine factrb
        subroutine fcblok(bloks,integs,nbloks,ipivot,scrtch,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(*),intent(inout) :: bloks
            integer(kind=4) dimension(3,nbloks),intent(in) :: integs
            integer(kind=4), optional,intent(in),check(shape(integs,1)==nbloks),depend(integs) :: nbloks=shape(integs,1)
            integer(kind=4) dimension(*),intent(out) :: ipivot
            real(kind=8) dimension(*),intent(out) :: scrtch
            integer(kind=4) intent(out) :: iflag
        end subroutine fcblok
        subroutine interv(xt,lxt,x,left,mflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(lxt),intent(in) :: xt
            integer(kind=4), optional,intent(in),check(len(xt)>=lxt),depend(xt) :: lxt=len(xt)
            real(kind=8) intent(in) :: x
            integer(kind=4) intent(out) :: left
            integer(kind=4) intent(out) :: mflag
        end subroutine interv
        subroutine knots(breaks,l,kpm,m,t,n) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(l + 1),intent(in) :: breaks
            integer(kind=4), optional,intent(in),check((len(breaks)-1)>=l),depend(breaks) :: l=(len(breaks)-1)
            integer(kind=4) intent(in) :: kpm
            integer(kind=4) intent(in) :: m
            real(kind=8) dimension(l*kpm+kpm-l*m+m),intent(out),depend(l,kpm,m) :: t
            integer(kind=4) intent(out) :: n
        end subroutine knots
        subroutine l2appr(t,n,k,q,diag,bcoef) ! in :pppack:../../src/pppack/f90/pppack.f90
            use l2ir_data
            real(kind=8) dimension(n+k),intent(in),depend(n,k) :: t
            integer(kind=4) intent(in) :: n
            integer(kind=4) intent(in) :: k
            real(kind=8) dimension(k,n),intent(out),depend(k,n) :: q
            real(kind=8) dimension(n),intent(out),depend(n) :: diag
            real(kind=8) dimension(n),intent(out),depend(n) :: bcoef
        end subroutine l2appr
        subroutine l2err(iprfun,breaks,coef,l,k,ntau,tau,gtau,weight,ftau,error) ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4) intent(in) :: iprfun
            real(kind=8) dimension(l + 1),intent(in) :: breaks
            real(kind=8) dimension(k,l),intent(in),depend(l) :: coef
            integer(kind=4), optional,intent(in),check((len(breaks)-1)>=l),depend(breaks) :: l=(len(breaks)-1)
            integer(kind=4), optional,intent(in),check(shape(coef,0)==k),depend(coef) :: k=shape(coef,0)
            integer(kind=4), optional,intent(in),check(len(tau)>=ntau),depend(tau) :: ntau=len(tau)
            real(kind=8) dimension(ntau),intent(in) :: tau
            real(kind=8) dimension(ntau),intent(in),depend(ntau) :: gtau
            real(kind=8) dimension(ntau),intent(in),depend(ntau) :: weight
            real(kind=8) dimension(ntau),intent(out),depend(ntau) :: ftau
            real(kind=8) dimension(ntau),intent(out),depend(ntau) :: error
        end subroutine l2err
        subroutine l2knts(breaks,l,k,t,n) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(l + 1),intent(in) :: breaks
            integer(kind=4), optional,intent(in),check((len(breaks)-1)>=l),depend(breaks) :: l=(len(breaks)-1)
            integer(kind=4) intent(in) :: k
            real(kind=8) dimension(k-1+l+k),intent(out),depend(l,k) :: t
            integer(kind=4) intent(out) :: n
        end subroutine l2knts
        subroutine newnot(breaks,coef,l,k,brknew,lnew,coefg) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(l + 1),intent(in) :: breaks
            real(kind=8) dimension(k,l),intent(in),depend(l) :: coef
            integer(kind=4), optional,intent(in),check((len(breaks)-1)>=l),depend(breaks) :: l=(len(breaks)-1)
            integer(kind=4), optional,intent(in),check(shape(coef,0)==k),depend(coef) :: k=shape(coef,0)
            real(kind=8) dimension(lnew + 1),intent(out),depend(lnew) :: brknew
            integer(kind=4) intent(in) :: lnew
            real(kind=8) dimension(2,l),intent(out),depend(l) :: coefg
        end subroutine newnot
        function ppvalu(breaks,coef,l,k,x,jderiv) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(l + 1),intent(in) :: breaks
            real(kind=8) dimension(k,l),intent(in),depend(l) :: coef
            integer(kind=4), optional,intent(in),check((len(breaks)-1)>=l),depend(breaks) :: l=(len(breaks)-1)
            integer(kind=4), optional,intent(in),check(shape(coef,0)==k),depend(coef) :: k=shape(coef,0)
            real(kind=8) intent(in) :: x
            integer(kind=4) intent(in) :: jderiv
            real(kind=8) :: ppvalu
        end function ppvalu
        subroutine putit(t,kpm,left,scrtch,dbiatx,q,nrow,b) ! in :pppack:../../src/pppack/f90/pppack.f90
            use colloc_data
            real(kind=8) dimension(left+kpm),intent(in),depend(kpm,left) :: t
            integer(kind=4), optional,intent(in),check(shape(dbiatx,0)==kpm),depend(dbiatx) :: kpm=shape(dbiatx,0)
            integer(kind=4) intent(in) :: left
            real(kind=8) dimension(kpm,kpm),intent(out),depend(kpm,kpm) :: scrtch
            real(kind=8) dimension(kpm,*),intent(inout) :: dbiatx
            real(kind=8) dimension(nrow,kpm),intent(out),depend(nrow,kpm) :: q
            integer(kind=4) intent(in) :: nrow
            real(kind=8) dimension(nrow),intent(out),depend(nrow) :: b
        end subroutine putit
        subroutine r8vec_print(n,a,title) ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4), optional,intent(in),check(len(a)>=n),depend(a) :: n=len(a)
            real(kind=8) dimension(n),intent(in) :: a
            character*(*) intent(in) :: title
        end subroutine r8vec_print
        function round(x,size_bn) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) intent(in) :: x
            real(kind=8) intent(in) :: size_bn
            real(kind=8) :: round
        end function round
        subroutine sbblok(bloks,integs,nbloks,ipivot,b,x) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(*),intent(in) :: bloks
            integer(kind=4) dimension(3,nbloks),intent(in) :: integs
            integer(kind=4), optional,intent(in),check(shape(integs,1)==nbloks),depend(integs) :: nbloks=shape(integs,1)
            integer(kind=4) dimension(*),intent(in) :: ipivot
            real(kind=8) dimension(*),intent(in) :: b
            real(kind=8) dimension(*),intent(out) :: x
        end subroutine sbblok
        subroutine setupq(x,dx,y,npoint,v,qty) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(npoint),intent(in) :: x
            real(kind=8) dimension(npoint),intent(in),depend(npoint) :: dx
            real(kind=8) dimension(npoint),intent(in),depend(npoint) :: y
            integer(kind=4), optional,intent(in),check(len(x)>=npoint),depend(x) :: npoint=len(x)
            real(kind=8) dimension(npoint,7),intent(out),depend(npoint) :: v
            real(kind=8) dimension(npoint),intent(out),depend(npoint) :: qty
        end subroutine setupq
        subroutine shiftb(ai,ipivot,nrowi,ncoli,last,ai1,nrowi1,ncoli1) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nrowi,ncoli),intent(in) :: ai
            integer(kind=4) dimension(nrowi),intent(in),depend(nrowi) :: ipivot
            integer(kind=4), optional,intent(in),check(shape(ai,0)==nrowi),depend(ai) :: nrowi=shape(ai,0)
            integer(kind=4), optional,intent(in),check(shape(ai,1)==ncoli),depend(ai) :: ncoli=shape(ai,1)
            integer(kind=4) intent(in) :: last
            real(kind=8) dimension(nrowi1,ncoli1),intent(inout) :: ai1
            integer(kind=4), optional,intent(in),check(shape(ai1,0)==nrowi1),depend(ai1) :: nrowi1=shape(ai1,0)
            integer(kind=4), optional,intent(in),check(shape(ai1,1)==ncoli1),depend(ai1) :: ncoli1=shape(ai1,1)
        end subroutine shiftb
        subroutine slvblk(bloks,integs,nbloks,b,ipivot,x,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(*),intent(inout) :: bloks
            integer(kind=4) dimension(3,nbloks),intent(in) :: integs
            integer(kind=4), optional,intent(in),check(shape(integs,1)==nbloks),depend(integs) :: nbloks=shape(integs,1)
            real(kind=8) dimension(*),intent(in) :: b
            integer(kind=4) dimension(*),intent(out) :: ipivot
            real(kind=8) dimension(*),intent(out) :: x
            integer(kind=4) intent(out) :: iflag
        end subroutine slvblk
        subroutine smooth(x,y,dy,npoint,s,v,a,sfq) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(npoint),intent(in) :: x
            real(kind=8) dimension(npoint),intent(in),depend(npoint) :: y
            real(kind=8) dimension(npoint),intent(in),depend(npoint) :: dy
            integer(kind=4), optional,intent(in),check(len(x)>=npoint),depend(x) :: npoint=len(x)
            real(kind=8) intent(in) :: s
            real(kind=8) dimension(npoint,7),intent(out),depend(npoint) :: v
            real(kind=8) dimension(npoint,4),intent(out),depend(npoint) :: a
            real(kind=8) intent(out) :: sfq
        end subroutine smooth
        subroutine spli2d(tau,gtau,t,n,k,m,work,q,bcoef,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(n),intent(in),depend(n) :: tau
            real(kind=8) dimension(*,*),intent(in) :: gtau
            real(kind=8) dimension(n+k),intent(in),depend(n,k) :: t
            integer(kind=4), optional,intent(in),depend(gtau) :: n=shape(gtau,0)
            integer(kind=4) intent(in) :: k
            integer(kind=4), optional,intent(in),check(n*m == shape(gtau,0)*shape(gtau,1)),depend(gtau,n) :: m=shape(gtau,1)
            real(kind=8) dimension(n),intent(out),depend(n) :: work
            real(kind=8) dimension((2*k-1)*n),intent(out),depend(n,k) :: q
            real(kind=8) dimension(m,n),intent(out),depend(m,n) :: bcoef
            integer(kind=4) intent(out) :: iflag
        end subroutine spli2d
        subroutine splint(tau,gtau,t,n,k,q,bcoef,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(n),intent(in) :: tau
            real(kind=8) dimension(n),intent(in),depend(n) :: gtau
            real(kind=8) dimension(n+k),intent(in),depend(n,k) :: t
            integer(kind=4), optional,intent(in),check(len(tau)>=n),depend(tau) :: n=len(tau)
            integer(kind=4) intent(in) :: k
            real(kind=8) dimension((2*k-1)*n),intent(out),depend(n,k) :: q
            real(kind=8) dimension(n),intent(out),depend(n) :: bcoef
            integer(kind=4) intent(out) :: iflag
        end subroutine splint
        subroutine splopt(tau,n,k,scrtch,t,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(n),intent(in) :: tau
            integer(kind=4), optional,intent(in),check(len(tau)>=n),depend(tau) :: n=len(tau)
            integer(kind=4) intent(in) :: k
            real(kind=8) dimension((n-k)*(2*k+3)+5*k+3),intent(out),depend(n,k) :: scrtch
            real(kind=8) dimension(n+k),intent(out),depend(n,k) :: t
            integer(kind=4) intent(out) :: iflag
        end subroutine splopt
        subroutine subbak(w,ipivot,nrow,ncol,last,x) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nrow,ncol),intent(in) :: w
            integer(kind=4) dimension(nrow),intent(in),depend(nrow) :: ipivot
            integer(kind=4), optional,intent(in),check(shape(w,0)==nrow),depend(w) :: nrow=shape(w,0)
            integer(kind=4), optional,intent(in),check(shape(w,1)==ncol),depend(w) :: ncol=shape(w,1)
            integer(kind=4) intent(in) :: last
            real(kind=8) dimension(ncol),intent(inout),depend(ncol) :: x
        end subroutine subbak
        subroutine subfor(w,ipivot,nrow,last,b,x) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(nrow,last),intent(in) :: w
            integer(kind=4) dimension(nrow),intent(in),depend(nrow) :: ipivot
            integer(kind=4), optional,intent(in),check(shape(w,0)==nrow),depend(w) :: nrow=shape(w,0)
            integer(kind=4), optional,intent(in),check(shape(w,1)==last),depend(w) :: last=shape(w,1)
            real(kind=8) dimension(nrow+nrow-last),intent(inout),depend(nrow,last) :: b
            real(kind=8) dimension(nrow),intent(out),depend(nrow) :: x
        end subroutine subfor
        subroutine tautsp(tau,gtau,ntau,gamma,s,breaks,coef,l,k,iflag) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(ntau),intent(in) :: tau
            real(kind=8) dimension(ntau),intent(in),depend(ntau) :: gtau
            integer(kind=4), optional,intent(in),check(len(tau)>=ntau),depend(tau) :: ntau=len(tau)
            real(kind=8) intent(in) :: gamma
            real(kind=8) dimension(ntau,6),intent(out),depend(ntau) :: s
            real(kind=8) dimension(*),intent(out) :: breaks
            real(kind=8) dimension(4,*),intent(out) :: coef
            integer(kind=4) intent(out) :: l
            integer(kind=4) intent(out) :: k
            integer(kind=4) intent(out) :: iflag
        end subroutine tautsp
        subroutine titand(t,g,n) ! in :pppack:../../src/pppack/f90/pppack.f90
            real(kind=8) dimension(*),intent(out) :: t
            real(kind=8) dimension(*),intent(out) :: g
            integer(kind=4) intent(out) :: n
        end subroutine titand
        subroutine newton_coef_1d(n,x,f,d) ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4), optional,intent(in),check(len(x)>=n),depend(x) :: n=len(x)
            real(kind=8) dimension(n),intent(in) :: x
            real(kind=8) dimension(n),intent(in),depend(n) :: f
            real(kind=8) dimension(n),intent(out),depend(n) :: d
        end subroutine newton_coef_1d
        subroutine newton_coef_nd(n,m,x,f,d) ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4), optional,intent(in),depend(f) :: n=shape(f,0)
            integer(kind=4), optional,intent(in),check(n*m == shape(f,0)*shape(f,1)),depend(f,n) :: m=shape(f,1)
            real(kind=8) dimension(n),intent(in),depend(n) :: x
            real(kind=8) dimension(*,*),intent(in) :: f
            real(kind=8) dimension(m,n),intent(out),depend(m,n) :: d
        end subroutine newton_coef_nd
        subroutine newton_value_1d(n,x,d,ni,xi,fi) ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4), optional,intent(in),check(len(x)>=n),depend(x) :: n=len(x)
            real(kind=8) dimension(n),intent(in) :: x
            real(kind=8) dimension(n),intent(in),depend(n) :: d
            integer(kind=4), optional,intent(in),check(len(xi)>=ni),depend(xi) :: ni=len(xi)
            real(kind=8) dimension(ni),intent(in) :: xi
            real(kind=8) dimension(ni),intent(out),depend(ni) :: fi
        end subroutine newton_value_1d
        subroutine newton_value_nd(n,m,x,d,xi,fi) ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4), optional,intent(in),depend(d) :: n=shape(d,0)
            integer(kind=4), optional,intent(in),check(n*m == shape(d,0)*shape(d,1)),depend(d,n) :: m=shape(d,1)
            real(kind=8) dimension(n),intent(in),depend(n) :: x
            real(kind=8) dimension(*,*),intent(in) :: d
            real(kind=8) intent(in) :: xi
            real(kind=8) dimension(m),intent(out),depend(m) :: fi
        end subroutine newton_value_nd
        subroutine r8vec2_print(n,a1,a2,title) ! in :pppack:../../src/pppack/f90/pppack.f90
            integer(kind=4), optional,intent(in),check(len(a1)>=n),depend(a1) :: n=len(a1)
            real(kind=8) dimension(n),intent(in) :: a1
            real(kind=8) dimension(n),intent(in),depend(n) :: a2
            character*(*) intent(in) :: title
        end subroutine r8vec2_print
        subroutine timestamp ! in :pppack:../../src/pppack/f90/pppack.f90
        end subroutine timestamp
    end interface 
end python module pppack

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
