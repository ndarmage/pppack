import numpy as np
import itertools as itt

import pppack as ppk


def cmpgtau(tau, g):
    "Compute g values at all points in tau in the associated dimension."
    # compute length of each row of tau
    if isinstance(tau[0], (list, tuple, np.ndarray)):
        Ni = [len(t) for t in tau]
    else:
        Ni = [len(tau)]
    # N, number of elements generated by cartesian product of tau dimensions
    N = np.prod(Ni)
    # order = 'F' stores array in Fortran-style (column-major order in memory)
    gtau = np.zeros((N,), order='F')

    # zip iterates several iterators simultaneously
    # itt.product = itertools.product: cartesian product of iterable
    # itt.product(*iterables); *tau split tau in each of its dimension
    for x, i in zip(itt.product(*tau), itt.product(*[range(nx) for nx in Ni])):
        # assign g(*x) value to the corresponding gtau index (1-dimensional)
        gtau[ppk.getidx(i, Ni)] = g(*x)
    return gtau


def chkapprx(tau, f, g):
    "Check interpolation by computing the interpolated values at data points."
    print("{:^13s} {:^13s} {:<13s}".format("Interpolation", "g values",
                                           "Rel. error (%)"))
    for x in itt.product(*tau):
        fx, gx = f(x), g(*x)
        print("%+13.6e %+13.6e %+7.2f" % (fx, gx, (1. - fx / gx) * 100))


def g3(x, y, z):
    return np.sin(x) / (x + 1) + (z + 1) * y**2 + x * np.exp(z) + .25


def g2(x, y):
    return g3(x, y, 0)


def g1(x):
    return g2(x, 0)


def make_plot(x_values, f, g, xlabel='x', ylabel='(a.u.)'):
    "Plot the interpolation error"
    import matplotlib.pyplot as plt
    interp_values = [f(x) for x in x_values]
    g_values = [g(x) for x in x_values]
    fig, ax = plt.subplots(1, 1)
    ax.plot(x_values, interp_values,'+', color='red', markersize=10,
            label='Interp. function')
    ax.plot(x_values, g_values, '--', label='Exact function')
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ae = ax.twinx()
    rerr = (1 - np.array(interp_values) / np.array(g_values)) * 100
    ae.plot(x_values, rerr, 'k', lw=1)
    ae.set_ylabel('Rel. Error (%)')
    ax.legend()
    plt.tight_layout()
    plt.show()
    plt.close(fig)


def run_test():
    # degree, knot vector, break points
    k, t, xi = 4, np.zeros((17,), order='F'), [0., 1.]
    n = len(t) - k
    # knot vector definition with "not-a-knot" condition and uniform
    # distribution
    t[0:k] = 0.
    t[n:] = 10.
    for i in range(1, 10):
        t[k + i - 1] = float(i)

    # Create piecewise polynomial spaces
    S1 = ppk.S(k, t)  # Space of B-splines of order k and knot sequence t
    P1 = ppk.Fd(ppk.PP(3, xi), name="quadratic")
    P2 = ppk.PP(2, xi)
    P2.name = "linear"  # two different syntaxes work
    V1 = P1 * P2
    V1.name = "poly"
    S2 = ppk.S(k, t)  # like a deepcopy of S1
    V2 = ppk.Fd(S1, S2, name="2D-bspline")
    V3 = ppk.Fd(P1, P2, ppk.PP(2, xi, name="linear2"), name="3D-poly")
    V4 = ppk.Fd(P1, S2, P2, name="3D-mix")

    print(" --- Interpolation tests ---\n"
          "*** check whether interpolation error is small ***\n"
          "*** at given data points in common use cases   ***")

    print("\n --- test 1D poly ---")
    f1 = ppk.fd.inFd(P1)
    tau = [[0., .5, 1.]]  # quadratic
    gtau = cmpgtau(tau, g1)
    f1.cmpcoef(tau, gtau)
    chkapprx(tau, f1, g1)
    # make_plot(np.linspace(0, 1, 20), f1, g1)

    print("\n --- test 2D poly ---")
    f2 = ppk.fd.inFd(V1)
    tau.append([0., 1.])  # linear
    gtau = cmpgtau(tau, g2)
    f2.cmpcoef(tau, gtau)
    chkapprx(tau, f2, g2)

    print("\n --- test 2D Bspline ---")
    h2 = ppk.fd.inFd(V2)
    tau = []
    for V in V2:
        tau.append(V.cmptau())
    gtau = cmpgtau(tau, g2)
    h2.cmpcoef(tau, gtau)
    chkapprx(tau, h2, g2)

    print("\n --- test 3D poly ---")
    f3 = ppk.fd.inFd(V3)
    tau = [[0., .5, 1.]]  # quadratic
    tau.append([0., 1.])  # linear
    tau.append([0., 1.])  # linear
    gtau = cmpgtau(tau, g3)
    f3.cmpcoef(tau, gtau)
    chkapprx(tau, f3, g3)

    print("\n --- test 3D mix ---")
    f4 = ppk.fd.inFd(V4)
    tau = [[0., .5, 1.]]  # quadratic
    tau.append(S2.cmptau())
    tau.append([0., 1.])  # linear
    gtau = cmpgtau(tau, g3)
    f4.cmpcoef(tau, gtau)
    chkapprx(tau, f4, g3)


if __name__ == "__main__":

    run_test()
