import numpy as np
import itertools as itt
import pppack as ppk
import matplotlib.pyplot as plt

def cmpgtau(tau,g): # compute g values at tau in the associated dimension
    Ni=[len(t) for t in tau] # compute length of each row of tau
    N=np.prod(Ni) # number of elements generated by cartesian product of tau dimensions
    gtau=np.zeros((N,), order='F') # order = 'F' stores array in Fortran-style (column-major order in memory)
    for x,i in zip(itt.product(*tau), \
               itt.product(*[range(nx) for nx in Ni])): 
        # zip iterates several iterators simultaneously
        # itt.product = itertools.product : cartesian product of iterable itt.product(*iterables)
        # *tau split tau in each of its dimension 
        gtau[ppk.getidx(i,Ni)]=g(*x) # assign g(*x) value to the corresponding gtau index (1-dimensional)
    return gtau

def chkapprx(tau,f,g): # compute interpolated values at data points
    print("Interp values -    g values   - Relative error ")
    for x in itt.product(*tau):
        fx,gx=f(x),g(*x)
        print("%+13.6e - %+13.6e - %+7.2f"%(fx,gx,(1.-fx/gx)*100.))

g3= lambda x,y,z: np.sin(x)/(x+.1)+(z+1.)*y**2+x*np.exp(z)+.25
g2= lambda x,y: g3(x,y,0.)
g1= lambda x: g2(x,0) # define a function 


def run_test():
    # degree, knot vector, break points
    k,t,xi=4,np.zeros((17,), order='F'),[0.,1.]
    n=len(t)-k
    # knot vector definition with "not-a-knot" condition and uniform distribution
    t[0:k]=0.; t[n:]=10.
    for i in range(1,n-k+1): t[k + i - 1]=float(i*(t[-1]-t[0])/(n-k+1)+t[0])

    # Create piecewise polynomial spaces 
    S1=ppk.S(k,t) # Space of B-splines of order k and knot sequence t
    P1=ppk.Fd(ppk.PP(3,xi),name="quadratic")
    P2=ppk.PP(2,xi); P2.name="linear" # two different syntaxes work
    V1=P1*P2; V1.name="poly"
    S2=ppk.S(k,t) # like a deepcopy of S1
    V2=ppk.Fd(S1,S2, name="2D-bspline")
    V3=ppk.Fd(P1,P2,ppk.PP(2,xi,name="linear2"), name="3D-poly")
    V4=ppk.Fd(P1,S2,P2, name="3D-mix")

    print(" --- Interpolation test : check whether interpolation error is 0 at given data points in common use cases ---")

    print(" ")
    print(" --- test 1D poly ---")

    f1=ppk.fd.inFd(P1) # Init from the space Fd to which the interpolation function belongs
    tau=[]
    tau.append([0., .5, 1.]) # quadratic
    gtau=cmpgtau(tau,g1) # compute g values at data points 
    f1.cmpcoef(tau,gtau) # compute f1 coefficients given g values at data points
    chkapprx(tau,f1,g1) # compute f1 values at data points and interpolation error at those points

    ## Show interpolation quality visually # uncomment if launched in a python IDE
    # x_values = np.linspace(0,1,20)
    # y_inter_values = [f1((x,)) for x in x_values]
    # y_g_values = [g1(x) for x in x_values]
    # plt.figure()
    # plt.plot(x_values,y_inter_values,'ro',label = 'Interpolation function')
    # plt.plot(x_values,y_g_values,label = 'Exact function')
    # plt.title('Interpolation quality')
    # plt.xlabel('x')
    # plt.ylabel('y')
    # plt.legend(loc='upper left')
    # plt.show()

    print(" ")
    print(" --- test 2D poly ---")

    f2=ppk.fd.inFd(V1)
    tau.append([0.,     1.]) # linear # add an other dimension to tau
    gtau=cmpgtau(tau,g2) 
    f2.cmpcoef(tau,gtau)
    chkapprx(tau,f2,g2)


    print(" ")
    print(" --- test 2D Bspline ---")
    h2=ppk.fd.inFd(V2)
    tau=[]
    for V in V2: tau.append( V.cmptau() ) # compute data points with regards to the given knots (see tau4Ik in pppack.py)
    gtau=cmpgtau(tau,g2)
    h2.cmpcoef(tau,gtau)
    chkapprx(tau,h2,g2)

    print(" ")
    print(" --- test 3D poly ---")
    f3=ppk.fd.inFd(V3)
    tau=[]
    tau.append([0., .5, 1.]) # quadratic
    tau.append([0.,     1.]) # linear
    tau.append([0.,     1.]) # linear
    gtau=cmpgtau(tau,g3)
    f3.cmpcoef(tau,gtau)
    chkapprx(tau,f3,g3)

    print(" ")
    print(" --- test 3D mix ---")
    f4=ppk.fd.inFd(V4)
    tau=[]
    tau.append([0., .5, 1.]) # quadratic
    tau.append( S2.cmptau() )
    tau.append([0.,     1.]) # linear
    gtau=cmpgtau(tau,g3)
    f4.cmpcoef(tau,gtau)
    chkapprx(tau,f4,g3)

if __name__ == "__main__":

    run_test()
